<!doctype html>

<html lang="en-us">

	<head>
		<meta charset="utf-8">
		
		<title>Munchausen Numbers and How to Find Them - Zach Denton</title>
		
		<meta name="author" content="Zach Denton">
		<meta name="description" content="An introduction to Munchausen numbers and how to find them with various programming languages.">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
		<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Share+Tech:400">
		<link rel="stylesheet" href="../css/main.css">
		
	</head>
	
	<body>
	
		<div id="banner"></div>
		<header role="banner">
			<h1><a href="../">Zach Denton</a></h1>
			<nav>
			<ul>
				<li><a href="../about/">About</a></li>
				<li><a href="../archives/">Blog</a></li>
				<li><a href="../project-euler-solutions/">Euler</a></li>
				<li><a href="https://github.com/zacharydenton">GitHub</a></li>
				<li><a href="../resume.pdf">Resume</a></li>
			</ul>
			</nav>
		</header>

		<article>
  <h1>Munchausen Numbers and How to Find Them</h1>

  <p>There are those who would have you believe that <a href="http://en.wikipedia.org/wiki/Interesting_number_paradox">every number is interesting</a>. However, there are interesting numbers and then there are <em>interesting</em> numbers. Today I’m going to talk about numbers in the latter category.</p>
<p>Munchausen numbers are numbers with the property that the sum of their digits raised to themselves equals the number itself. I think this is best explained with an example:</p>
<p><br /><span class="math">3<sup>3</sup> + 4<sup>4</sup> + 3<sup>3</sup> + 5<sup>5</sup> = 3435</span><br /></p>
<p>I don’t know about you, but I find this extremely interesting! (Come on! You don’t think that’s interesting?) In any case, I decided to write a few different programs to find these numbers.</p>
<p>The basic algorithm I came up with is as follows:</p>
<ul>
<li>Separate the number into its constituent digits.</li>
<li>Find the sum of each digit raised to itself.</li>
<li>If this sum equals the original number, then it is a Munchausen number.</li>
</ul>
<p>That’s fairly self-explanatory, right? Let me show you a few different ways to do this.</p>
<h3 id="ruby">Ruby</h3>
<p>Ruby was the first “real” programming language I learned. Before Ruby, I was writing simple programs on my TI-89, but that doesn’t really count. If you’re wondering, I first learned how to program by reading the excellent <a href="http://pine.fm/LearnToProgram/" title="Learn to Program"><em>Learn to Program</em></a>, by Chris Pine.</p>
<p>In Ruby, the easiest way to get the digits of a number is simply to convert the number into a string. Once that is established, one simply needs to apply the aforementioned algorithm to each number within a certain limit to find the Munchausen numbers within that limit:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">#!/usr/bin/env ruby</span>
<span class="co"># munchausen.rb - finds munchausen numbers</span>

<span class="dv">5000</span>.times <span class="kw">do</span> |i|
    digits = i.to_s()
    sum = <span class="dv">0</span>
    digits.each_char <span class="kw">do</span> |digit|
        digit = digit.to_i()
        sum += digit ** digit
    <span class="kw">end</span>
    <span class="kw">if</span> sum == i
        puts i.to_s() + <span class="st">&quot; (munchausen)&quot;</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<h3 id="c">C</h3>
<p>C is great if you need to eke out every last drop of performance from your machine. I wouldn’t think of using it in any other case, though. That being said, it is much easier than assembly language, but come on people – this is the 21st century.</p>
<p>I took a slightly different approach here and used modular arithmetic to extract the digits from the number. To find the least significant digit, we take the remainder when the number is divided by 10. We do this until all digits have been extracted. Then we simply apply the algorithm as in the previous example.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// calculate munchausen numbers</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="dt">int</span> limit = <span class="dv">5000</span>; <span class="co">// the upper bound of the search</span>

<span class="dt">int</span> i;
<span class="dt">int</span> main() {
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; limit; i++) {
        <span class="co">// loop through each digit in i</span>
        <span class="co">// e.g. for 1000 we get 0, 0, 0, 1.</span>
        <span class="dt">int</span> number = i;
        <span class="dt">int</span> sum = <span class="dv">0</span>;
        <span class="kw">while</span> (number &gt; <span class="dv">0</span>) {
            <span class="dt">int</span> digit = number % <span class="dv">10</span>;
            number = number / <span class="dv">10</span>;
            <span class="co">// find the sum of the digits </span>
            <span class="co">// raised to themselves </span>
            sum += pow(digit, digit);
        }
        <span class="kw">if</span> (sum == i) {
            <span class="co">// the sum is equal to the number</span>
            <span class="co">// itself; thus it is a </span>
            <span class="co">// munchausen number</span>
            printf(<span class="st">&quot;%i (munchausen)</span><span class="ch">\n</span><span class="st">&quot;</span>, i);
        } 
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h3 id="clojure">Clojure</h3>
<p>Clojure is an interesting new language, conceived in 2008. It is a Lisp which targets the Java Virtual Machine, meaning it can make use of any existing Java code whilst being written in a functional style.</p>
<p>Functional programming is an intriguing concept. It seems more theoretical than the imperative style I am used to, but perhaps that is because I am learning the language by reading <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" title="Structure and Interpretation of Computer Programs"><em>Structure and Interpretation of Computer Programs</em></a>.</p>
<p>One thing about Clojure that seems strange to me is the fact that it lacks a standard library. This means that you have to define your own exponentiation function. In this case, I just used a function from the Java standard library.</p>
<p>The other idiosyncrasy I noticed is that in Clojure, converting a char to an int returns the ASCII representation of that char, rather than performing a direct conversion. Thus, we must subtract 48 in order to receive the number itself.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">#!/usr/bin/env clojure
(<span class="kw">defn</span><span class="fu"> ** </span>[x n]
  (. (. java.math.BigInteger (valueOf x)) (pow n)))

(<span class="kw">defn</span><span class="fu"> raise-to-itself </span>[number]
  (** number number))

(<span class="kw">defn</span><span class="fu"> digits </span>[number]
  <span class="co">; convert the number to a string,</span>
  <span class="co">; and convert each char to an int.</span>
  <span class="co">;</span>
  <span class="co">; subtract 48 because casting a char</span>
  <span class="co">; to an int returns the ASCII</span>
  <span class="co">; representation of that char.</span>
  (<span class="kw">map</span> #(<span class="kw">-</span> (<span class="kw">int</span> %) <span class="dv">48</span>) (<span class="kw">str</span> number))) 

(<span class="kw">defn</span><span class="fu"> munchausen</span>? [number]
  <span class="co">; if the sum of the digits raised to</span>
  <span class="co">; themselves is equal to the number </span>
  <span class="co">; itself, then it is a munchausen number.</span>
  (<span class="kw">=</span> (<span class="kw">apply</span> <span class="kw">+</span> (<span class="kw">map</span> raise-to-itself (digits number))) number))

(<span class="kw">def</span><span class="fu"> munchausen </span>(<span class="kw">filter</span> munchausen? (<span class="kw">range</span> <span class="dv">5000</span>)))
(<span class="kw">println</span> munchausen)</code></pre>
<h3 id="python">Python</h3>
<p>Python is easily my favorite language. Everything about it just seems “right”. Of course, this is probably because it is the language I use the most – but then we have a chicken-or-egg scenario, don’t we?</p>
<p>Here’s the program written in Python. I used it to find every Munchausen number less than 500,000,000. After thirty minutes or so of intense computation, it turns out that the only Munchausen numbers are 1 and 3435. Others have posited that 438,579,088 is a Munchausen number, but this is false because <span class="math">0<sup>0</sup> = 1</span>, at least in most programming languages.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python3</span>
<span class="co"># calculates munchausen numbers</span>
<span class="co">#</span>
<span class="co"># these are numbers with the property</span>
<span class="co"># that the sum of its digits raised</span>
<span class="co"># to themselves produces the original</span>
<span class="co"># number.</span>

<span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">5000</span>):
    digits = (<span class="dt">int</span>(digit) <span class="kw">for</span> digit in <span class="dt">str</span>(i))
    <span class="kw">if</span> <span class="dt">sum</span>(digit ** digit <span class="kw">for</span> digit in digits) == i:
        <span class="dt">print</span>(i, <span class="st">&quot;(munchausen)&quot;</span>)</code></pre>
</article>


		<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r67/three.min.js"></script>
		<script src="../js/main.js"></script>
	</body>
</html>
